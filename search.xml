<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F09%2FJava%E7%BA%BF%E7%A8%8B%E4%B8%ADstart%E6%96%B9%E6%B3%95%E5%92%8Crun%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[java中执行一个线程需要重写Thread类中的run()方法，而在Thread类中还存在一个start()方法。本文将分析start()方法和run()方法的区别。 首先看一段java代码。 1234567891011121314151617public class ThreadTest &#123; private static void greeting() &#123; System.out.println("hello!"); System.out.println("Current Thread is : " + Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; Thread t = new Thread() &#123; @Override public void run() &#123; greeting(); &#125; &#125;; System.out.println("Current main thread is : " + Thread.currentThread().getName()); t.run(); &#125;&#125; 上述代码中，ThreadTest类中定义了一个greeting()方法，在main函数中，新建了一个Thread对象，并实现了Thread类的run方法，run()方法里面调用了ThreadTest类的greeting()方法。最后通过Thread实例的run()方法来执行。执行结果如下： 123Current main thread is : mainhello!Current Thread is : main 执行结果表明，调用run()方法的线程是主线程。由此可见，通过Thread对象调用run()方法并没有创建一个子线程去执行，而是相当于一个普通方法的调用。 对上述代码进行修改： 1234567891011121314151617public class ThreadTest &#123; private static void greeting() &#123; System.out.println("hello!"); System.out.println("Current Thread is : " + Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; Thread t = new Thread() &#123; @Override public void run() &#123; greeting(); &#125; &#125;; System.out.println("Current main thread is : " + Thread.currentThread().getName()); t.start(); &#125;&#125; 在上面的代码中，我们通过t.run()改为了t.start()，执行结果怎么样呢？ 123Current main thread is : mainhello!Current Thread is : Thread-0 根据执行结果发现，通过start()方法的调用，会创建一个子线程来执行重写过的run()方法。 由此，我们可以得出两者的区别： 调用start()方法会创建一个新的子线程并启动，调用run()方法只相当于一个普通方法的调用。 那到底是什么原因导致的呢，我们要从源码层面进行分析。 查看Thread类中的start()方法，方法实现如下： 1234567891011121314151617181920212223242526272829303132public synchronized void start() &#123; /** * This method is not invoked for the main method thread or "system" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state "NEW". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; // 主要调用了start0()方法 start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125; 从start()方法的源码可以看出，start()方法主要是调用了start0()方法去执行任务的。所以我们需要继续查看start0()方法。 1private native void start0(); start0()方法是一个native方法，因此，我们需要查看start0()这个native方法的实现过程。我们可以通过openjdk去查看start0()方法对应的native方法。 源码地址如下： http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/f0b93fbd8cf8/src/share/native/java/lang/Thread.c 我们找出start0方法相关的代码 123456789101112131415161718static JNINativeMethod methods[] = &#123; &#123;"start0", "()V", (void *)&amp;JVM_StartThread&#125;, &#123;"stop0", "(" OBJ ")V", (void *)&amp;JVM_StopThread&#125;, &#123;"isAlive", "()Z", (void *)&amp;JVM_IsThreadAlive&#125;, &#123;"suspend0", "()V", (void *)&amp;JVM_SuspendThread&#125;, &#123;"resume0", "()V", (void *)&amp;JVM_ResumeThread&#125;, &#123;"setPriority0", "(I)V", (void *)&amp;JVM_SetThreadPriority&#125;, &#123;"yield", "()V", (void *)&amp;JVM_Yield&#125;, &#123;"sleep", "(J)V", (void *)&amp;JVM_Sleep&#125;, &#123;"currentThread", "()" THD, (void *)&amp;JVM_CurrentThread&#125;, &#123;"countStackFrames", "()I", (void *)&amp;JVM_CountStackFrames&#125;, &#123;"interrupt0", "()V", (void *)&amp;JVM_Interrupt&#125;, &#123;"isInterrupted", "(Z)Z", (void *)&amp;JVM_IsInterrupted&#125;, &#123;"holdsLock", "(" OBJ ")Z", (void *)&amp;JVM_HoldsLock&#125;, &#123;"getThreads", "()[" THD, (void *)&amp;JVM_GetAllThreads&#125;, &#123;"dumpThreads", "([" THD ")[[" STE, (void *)&amp;JVM_DumpThreads&#125;, &#123;"setNativeName", "(" STR ")V", (void *)&amp;JVM_SetNativeThreadName&#125;,&#125;; 发现，start0方法是通过JVM_StartThread方法实现的。Thread.c的头文件里有一个#include “jvm.h”，而JVM_StartThread方法以JVM开头，所以应该在jvm对应的C程序里。jvm的C程序地址如下： http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/111b95ad4584/src/share/vm/prims/jvm.cpp 搜索JVM_StartThread字段，找出与JVM_StartThread相关的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// java.lang.Thread //////////////////////////////////////////////////////////////////////////////// In most of the JVM Thread support functions we need to be sure to lock the Threads_lock// to prevent the target thread from exiting after we have a pointer to the C++ Thread or// OSThread objects. The exception to this rule is when the target object is the thread// doing the operation, in which case we know that the thread won't exit until the// operation is done (all exits being voluntary). There are a few cases where it is// rather silly to do operations on yourself, like resuming yourself or asking whether// you are alive. While these can still happen, they are not subject to deadlocks if// the lock is held while the operation occurs (this is not the case for suspend, for// instance), and are very unlikely. Because IsAlive needs to be fast and its// implementation is local to this file, we always lock Threads_lock for that one.static void thread_entry(JavaThread* thread, TRAPS) &#123; HandleMark hm(THREAD); Handle obj(THREAD, thread-&gt;threadObj()); JavaValue result(T_VOID); JavaCalls::call_virtual(&amp;result, obj, KlassHandle(THREAD, SystemDictionary::Thread_klass()), vmSymbols::run_method_name(), vmSymbols::void_method_signature(), THREAD);&#125;JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread)) JVMWrapper("JVM_StartThread"); JavaThread *native_thread = NULL; // We cannot hold the Threads_lock when we throw an exception, // due to rank ordering issues. Example: we might need to grab the // Heap_lock while we construct the exception. bool throw_illegal_thread_state = false; // We must release the Threads_lock before we can post a jvmti event // in Thread::start. &#123; // Ensure that the C++ Thread and OSThread structures aren't freed before // we operate. MutexLocker mu(Threads_lock); // Since JDK 5 the java.lang.Thread threadStatus is used to prevent // re-starting an already started thread, so we should usually find // that the JavaThread is null. However for a JNI attached thread // there is a small window between the Thread object being created // (with its JavaThread set) and the update to its threadStatus, so we // have to check for this if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) &#123; throw_illegal_thread_state = true; &#125; else &#123; // We could also check the stillborn flag to see if this thread was already stopped, but // for historical reasons we let the thread detect that itself when it starts running jlong size = java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread)); // Allocate the C++ Thread structure and create the native thread. The // stack size retrieved from java is signed, but the constructor takes // size_t (an unsigned type), so avoid passing negative values which would // result in really large stacks. size_t sz = size &gt; 0 ? (size_t) size : 0; native_thread = new JavaThread(&amp;thread_entry, sz); // At this point it may be possible that no osthread was created for the // JavaThread due to lack of memory. Check for this situation and throw // an exception if necessary. Eventually we may want to change this so // that we only grab the lock if the thread was created successfully - // then we can also do this check and throw the exception in the // JavaThread constructor. if (native_thread-&gt;osthread() != NULL) &#123; // Note: the current thread is not being used within "prepare". native_thread-&gt;prepare(jthread); &#125; &#125; &#125; if (throw_illegal_thread_state) &#123; THROW(vmSymbols::java_lang_IllegalThreadStateException()); &#125; assert(native_thread != NULL, "Starting null thread?"); if (native_thread-&gt;osthread() == NULL) &#123; // No one should hold a reference to the 'native_thread'. delete native_thread; if (JvmtiExport::should_post_resource_exhausted()) &#123; JvmtiExport::post_resource_exhausted( JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS, "unable to create new native thread"); &#125; THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), "unable to create new native thread"); &#125; Thread::start(native_thread); 找出关键语句： 1native_thread = new JavaThread(&amp;thread_entry, sz); 这句话新建了一个java线程，并传入了一个thread_entry。thread_entry的内容如下： 1234567891011static void thread_entry(JavaThread* thread, TRAPS) &#123; HandleMark hm(THREAD); Handle obj(THREAD, thread-&gt;threadObj()); JavaValue result(T_VOID); JavaCalls::call_virtual(&amp;result, obj, KlassHandle(THREAD, SystemDictionary::Thread_klass()), vmSymbols::run_method_name(), // vmSymbols::void_method_signature(), THREAD);&#125; 在thread_entry方法中，JavaCalls调用了Java虚拟机，并传入run_method_name()。也就是说，new 了一个java线程，并用这个线程去执行run方法。 总结一下，start()方法的调用过程如下： 所以，调用start()方法会创建一个新的子线程并启动，调用run()方法只相当于一个普通方法的调用。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis基础]]></title>
    <url>%2F2019%2F02%2F17%2Fredis%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[什么是redisredis是一个键值对形式的存储系统。支持多种语言，如C, Java, Python等。 redis应用场景redis可以应用于数据缓存，消息队列，排行榜或者计数，发布和订阅消息，商品列表评论列表等方面。 redis的数据类型redis包括5种数据类型，分别是字符串(string)，哈希(hash)，列表(list)，集合(set)以及有序集(zset)。 字符串相关操作 1234set key valuemset key1 value1 key2 value2 ...get keymget key1 key2 key3 ... 哈希相关操作 1234hset key field valuehget key fieldhmset key field1 value1 field2 value ...hget key field1 field2 field3 列表相关操作 1234lpush key value1 value2 ...rpush key value1 value2 ...lrange key start endllen key 集合相关操作 123sadd key membersrem key membersmembers key 有序集相关操作 1234zadd key score valuezcount key min maxzrem key valuezrangebyscore key min max redis的服务相关命令select 数据库 info config get flushdb redis的发布和订阅订阅：subscribe channel1 channel2 … 发布：publish channel message redis持久化第一种方式是快照 save 60 900。60秒内至少有900次数据变动，就保存一次快照。 第二种方式是附加文件。]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试通关要点汇总集(自答案)]]></title>
    <url>%2F2019%2F01%2F30%2FJava%E9%9D%A2%E8%AF%95%E9%80%9A%E5%85%B3%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB%E9%9B%86-%E8%87%AA%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[基本功面上对象的特征面向对象的基本特征是封装，继承和多态。 封装封装是指各个类对自己的属性进行封装，属性私有化。在java中，使用private关键字对类的属性进行私有化。 继承在java中，如果一个类没有被final修饰，那么这个类可以被继承。如果类A继承于类B，那么称类A为类B的子类，B类称为A类的父类或者超类或者基类。子类可以继承父类的属性和方法。子类可以对父类进行扩展，子类可以重写父类的方法。如果子类调用一个方法，会先在子类中查找有没有定义这个方法，如果定义了，则调用子类的方法，如果没有，则调用父类中的同名方法。任何类都继承于Object类，也就是说Object类是所类的父类。 在java中，用extends关键字表示继承关系。一个类的直接父类只能有一个。extends的使用如下： 12345678910111213141516171819202122232425262728public class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void eat() &#123; System.out.println("Person needs to eat"); &#125; public void walk() &#123; System.out.println("More walking, more healthy!"); &#125;&#125; 123456789101112131415public class Student extends Person &#123; private String stuId; public String getStuId() &#123; return this.stuId; &#125; public void setStuId(String stuId) &#123; this.stuId = stuId; &#125; public void eat() &#123; System.out.println("Student needs to eat."); &#125;&#125; 1234567public class ExtendsTest &#123; public static void main(String[] args) &#123; Student stu = new Student(); stu.eat(); stu.walk(); &#125;&#125; 结果如下： 12Student needs to eat.More walking, more healthy! 多态多态指一个类具有多种形态。 final, finally, finalize 的区别被final修饰的类无法被继承，被final修饰的属性初始化后不可以被修改，被final修饰的方法不能被重写。 finally是在捕获异常时配合使用的，在不管是否发生异常，都会执行finally中的语句。如果try或者catch块中的return语句会覆盖finally中的return 语句。 1234567try &#123; // TODO&#125; catch &#123; // TODO&#125; finally &#123; // finally块中的代码都会被执行&#125; finalize用于构造器的析构。 int 和 Integer 有什么区别int 是数据类型，Integer是int的包装类。从int转为Integer叫做自动装箱，由Integer转为int是自动拆箱。 重载和重写的区别子类定义一个与父类方法同名，参数类型相同的方法叫做重写。重载是指方法名相同，但方法的参数类型，参数顺序，参数个数不同的方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大排序Java语言描述]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8FJava%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[pykafka相关问题]]></title>
    <url>%2F2019%2F01%2F22%2Fpykafka%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[pykafka报错：NoBrokersAvailableError 123456789101112131415161718Traceback (most recent call last): File "/usr/lib64/python2.7/threading.py", line 812, in __bootstrap_inner self.run() File "/usr/lib64/python2.7/threading.py", line 765, in run self.__target(*self.__args, **self.__kwargs) File "kafkaService.py", line 272, in run_kafka kafka_service = KafkaService() File "kafkaService.py", line 121, in __init__ client = KafkaClient(hosts=servers) File "/usr/lib/python2.7/site-packages/pykafka-2.8.0-py2.7.egg/pykafka/client.py", line 142, in __init__ broker_version=broker_version) File "/usr/lib/python2.7/site-packages/pykafka-2.8.0-py2.7.egg/pykafka/cluster.py", line 215, in __init__ self.update() File "/usr/lib/python2.7/site-packages/pykafka-2.8.0-py2.7.egg/pykafka/cluster.py", line 510, in update metadata = self._get_metadata() File "/usr/lib/python2.7/site-packages/pykafka-2.8.0-py2.7.egg/pykafka/cluster.py", line 305, in _get_metadata 'Unable to connect to a broker to fetch metadata. See logs.')NoBrokersAvailableError: Unable to connect to a broker to fetch metadata. See logs. kafka报错没找到broker，但linux集群的kafka环境都已经正确启动，感觉有点奇怪。于是根据引文的建议，用ipython调用logging模块找到问题所在。进入ipython。 12345from pykafka import KafkaClientimport logging as loglog.basicConfig(level=log.DEBUG)# 然后执行如下语句，日志报错client = KafkaClient(hosts='192.168.1.230:9092,192.168.1.231:9092,192.168.1.232:9092') 报错信息如下： 1234567891011121314151617181920212223242526INFO:pykafka.cluster:Discovered 3 brokersDEBUG:pykafka.cluster:Discovered broker id 0: cmdb1:9092DEBUG:pykafka.connection:Connecting to cmdb1:9092INFO:pykafka.connection:Attempt 0: failed to connect to cmdb1:9092INFO:pykafka.connection:[Errno -2] Name or service not knownINFO:pykafka.connection:Retrying in 300ms.INFO:pykafka.connection:Attempt 1: failed to connect to cmdb1:9092INFO:pykafka.connection:[Errno -2] Name or service not knownINFO:pykafka.connection:Retrying in 300ms.INFO:pykafka.connection:Attempt 2: failed to connect to cmdb1:9092INFO:pykafka.connection:[Errno -2] Name or service not knownINFO:pykafka.connection:Retrying in 300ms.INFO:pykafka.handlers:RequestHandler worker: exiting cleanlyWARNING:pykafka.broker:Failed to connect to broker at cmdb1:9092. Check the `listeners` property in server.config.DEBUG:pykafka.cluster:Discovered broker id 1: cmdb2:9092DEBUG:pykafka.connection:Connecting to cmdb2:9092INFO:pykafka.connection:Attempt 0: failed to connect to cmdb2:9092INFO:pykafka.connection:[Errno -2] Name or service not knownINFO:pykafka.connection:Retrying in 300ms.INFO:pykafka.connection:Attempt 1: failed to connect to cmdb2:9092INFO:pykafka.connection:[Errno -2] Name or service not knownINFO:pykafka.connection:Retrying in 300ms.INFO:pykafka.connection:Attempt 2: failed to connect to cmdb2:9092INFO:pykafka.connection:[Errno -2] Name or service not knownINFO:pykafka.connection:Retrying in 300ms.WARNING:pykafka.broker:Failed to connect to broker at cmdb2:9092. Check the `listeners` property in server.config. 发现，cmdb1:9092，cmdb2:9092连接提示Name or service not known，估计原因可能是主机名和ip地址没有对应，于是修改/etc/hosts文件，将cmdb1和cmdb2与相应的ip地址相对应。 再次在ipython中执行如下代码 12345from pykafka import KafkaClientimport logging as loglog.basicConfig(level=log.DEBUG)# 然后执行如下语句，可以正常连接brokerclient = KafkaClient(hosts='192.168.1.230:9092,192.168.1.231:9092,192.168.1.232:9092') 日志输出如下： 12345678910111213141516171819202122232425DEBUG:pykafka.cluster:Updating cluster, attempt 1/3DEBUG:pykafka.connection:Connecting to 192.168.1.230:9092DEBUG:pykafka.connection:Successfully connected to 192.168.1.230:9092INFO:pykafka.handlers:RequestHandler.stop: about to flush requests queueINFO:pykafka.cluster:Discovered 3 brokersDEBUG:pykafka.cluster:Discovered broker id 0: cmdb1:9092DEBUG:pykafka.connection:Connecting to cmdb1:9092DEBUG:pykafka.connection:Successfully connected to cmdb1:9092DEBUG:pykafka.cluster:Discovered broker id 1: cmdb2:9092DEBUG:pykafka.connection:Connecting to cmdb2:9092DEBUG:pykafka.connection:Successfully connected to cmdb2:9092DEBUG:pykafka.cluster:Discovered broker id 3: cmdb3:9092DEBUG:pykafka.connection:Connecting to cmdb3:9092DEBUG:pykafka.connection:Successfully connected to cmdb3:9092INFO:pykafka.cluster:Discovered 11 topicsDEBUG:pykafka.cluster:Discovered topic 'test3'DEBUG:pykafka.cluster:Discovered topic 'test2'DEBUG:pykafka.cluster:Discovered topic 'TOPIC_SMS'DEBUG:pykafka.cluster:Discovered topic 'cmdb_collect_topic_test'DEBUG:pykafka.cluster:Discovered topic 'TOPIC_EMAIL'DEBUG:pykafka.cluster:Discovered topic 'ansible_task_test3'DEBUG:pykafka.cluster:Discovered topic 'TOPIC_WX'DEBUG:pykafka.cluster:Discovered topic 'test'DEBUG:pykafka.cluster:Discovered topic 'TOPIC_COMM'DEBUG:pykafka.cluster:Discovered topic 'ansible_task_result' 由此，问题得到解决。 参考：pykafka常见问题分析与记录]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pykafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka集群搭建]]></title>
    <url>%2F2019%2F01%2F21%2Fkafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[转载kafka集群搭建 这篇博文写的很详细，成功搭建kafka集群。]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2019%2F01%2F20%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[能够分析类能力的程序称为反射。 Class类在程序运行期间，java运行时系统始终未所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。 可以通过专门的Java类访问这些信息，保存这些信息的类称为Class。Object类中有一个getClass()方法可以返回一个Class类型的实例。一个Class对象将表示一个特定类的属性。最常用的Class方法是getName方法，该方法返回类的名字。 12345678910111213141516171819package com.reflection;public class Employee &#123; private String name; private int age; public Employee(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125;&#125; 123456789package com.reflection;public class Test1 &#123; public static void main(String[] args) &#123; Employee e = new Employee("xiaoming", 10); Class c1 = e.getClass(); System.out.println(c1.getName()); // com.reflection.Employee &#125;&#125; 利用Class类的forName()方法可以获得类名对应的Class对象。 12345678910111213package com.reflection;public class Test1 &#123; public static void main(String[] args) &#123; String className = "java.util.Random"; try &#123; Class c2 = Class.forName(className); System.out.println(c2.getName()); &#125; catch (ClassNotFoundException e1) &#123; e1.printStackTrace(); &#125; &#125;&#125; 这个方法只有在className是类名或者接口名的时候才能够执行。否则将会抛出一个checked exception。 在启动时，包含main方法的类被加载，它会加载所有需要的类。这些被加载的类又会加载他们需要的类，以此类推。对于一个大型的程序来说，会消耗很多时间。 如果T是任意类型的Java类型(或者void关键字)，T.class将代表匹配的类对象。 123Class c1 = Random.class;Class c2 = int.class;class c3 = Double[].class; 一个Class对象实际是一种类型，这个类型不一定是一种类。 虚拟机为每个类型管理一个Class对象。因此可以用==运算符实现两个类对象比较的操作。 newInstance()方法可以动态的创建一个类的实例。它会调用这个这个类的默认方法，如果该类没有提供默认构造器，那么将会抛出异常。 利用反射分析类的能力检查类的结构。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基础知识]]></title>
    <url>%2F2019%2F01%2F19%2Flinux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[linux 基础命令切换目录12345cd user # 切换到当前目录下的user目录cd .. # 打开上一级目录cd / # 切换到系统根目录cd ~ # 切换到当前用户的主目录cd - # 切换到上一个命令所在的目录 目录的操作命令(增删改查)创建目录12mkdir mydir # 在当前目录下创建mydir目录mkdir -p lcx/test # 在当前的lcx目录下创建test目录，如果lcx目录不存在，则创建 查看目录信息123ls # 查看当前目录下的文件(不包括以"."开头的文件)ls -a # 查看当前目录下的所有文件（包括以 "." 开头的文件)ll # ls -l的缩写。查看当前目录下所有文件和目录的详细信息(我一般使用这个命令查看权限较多) find命令用法：find 目录 参数 123find . # 列出当前目录以及子目录下的所有文件和文件夹find / -name "*.txt" # 找出系统根目录下以.txt结尾的文件find / -iname "*.txt" # 同上，但忽略大小写 mv命令mv命令可以对目录、文件进行重命名，也可以将一个文件从一个目录移动到另一个目录 12mv lcx user # 将lcx目录重新命名为user目录mv lcx.txt ../user # 将lcx.txt从当前目录移动到上级目录的user目录 cp 命令cp命令对文件和目录进行复制。用法：cp 目录名称 目标目录名称 12cp -r lcx lcx2 # 将lcx目录复制到lcx2目录，-r表示递归复制cp lcx.txt lcx2.txt # 将lcx.txt 复制一份到lcx2.txt 删除目录1rm -rf lcx # 删除lcx目录 文件操作相关命令创建文件1touch 1.txt # 创建1.txt 查看文件内容1cat 1.txt # 查看1.txt的内容 编辑文件内容1vim 1.txt # 编辑1.txt。按i进入vim的编辑模式，编辑好之后按ESC进入命令模式，最后按":wq"保存编辑好的文件并退出 删除文件1rm -rf 1.txt # 删除1.txt 权限命令操作系统中每个文件都有特定的权限，所属用户和组。权限分为三种：读(r)、写(w)、执行(x)。通过ll命令可以查看文件权限。 文件类型：d表示目录，-表示文件，l表示链接 权限类型读：用r表示，也可以用数字4表示 写：用w表示，也可以用数字2表示 执行：用x表示，也可以用数字1表示 对于文件： 权限名称 可执行操作 r 可以使用cat查看文件的内容 w 可以修改文件的内容 x 可以将其运行为二进制文件 对于目录： 权限名称 可执行操作 r 可以查看目录下列表 w 可以创建和删除目录下文件 x 可以使用cd进入目录 相关命令123chmod 755 lcx.txt # 设置lcx.txt的权限为所属者为读写执行(4+2+1)，该文件所在组的用户和其他用户执行权限为读和执行(4+1)chown shqz lcx.txt # 设置lcx.txt的所属者为shqzchgrp shqz lcx.txt # 修改lcx.txt的所在的组为shqz 查看进程123ps -ef | grep kafka # 查看包括kafka字符串的进程ps aux | grep kafka # 同上，只是表示格式不同kill -9 进程的pid # -9 表示强制杀死进程]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nexus安装步骤]]></title>
    <url>%2F2019%2F01%2F18%2Fnexus%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[拉取安装包(nexus-3.15.1-01-unix.tar.gz)到指定目录打开8081端口 123tar -zxvf nexus-3.15.1-01-unix.tar.gzcd nexus-3.15.1-01/bin./nexus run &amp; 启动成功即可。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>nexus</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java值传递]]></title>
    <url>%2F2019%2F01%2F18%2FJava%E5%80%BC%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[linux免密登录]]></title>
    <url>%2F2019%2F01%2F18%2Flinux%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[环境两台主机：192.168.1.230 192.168.1.231。现在需要通过ssh，实现192.168.1.230到231的免密登录。 生成密钥在192.168.1.230上生成一对密钥，一个作为公钥，一个作为s私钥。如果已有对应的公钥和私钥，则不需要这一步。命令如下： 1ssh-keygen 一直按回车就行。 出现红框内的图案表示密钥生成成功。可以发现用户的.ssh目录下出现了id_rsa和id_rsa.pub，前者为私钥，后者为公钥。 部署公钥到目标主机在当前服务器执行ssh-copy-id命令，将公钥部署到目标服务器，用法如下： 12# 命令格式：ssh-copy-id 用户名@ip地址ssh-copy-id shqz@192.168.1.231 执行这条命令之后需要输入目标主机的登录密码，输入之后即可进行免密登录。 出现上图表示公钥部署成功。 免密登录前面已经将密钥配置完成，最后只需要执行如下ssh命令即可免密登录： 1ssh shqz@192.168.1.231 发现，无需输入密码就登录到目标主机。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible问题记录]]></title>
    <url>%2F2019%2F01%2F18%2Fansible%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[关于aixansible连接不了aix服务器首先判断是不是aix服务器上没有python环境，如果没有，需要先安装合适版本的python环境。发现安装python环境之后依旧连接不上，不知道问题在哪。后来尝试加入连接方式，使用命令行参数-c，指定连接方式为paramiko，就连接成功了。 ansible无法执行aix的任务使用raw模块在aix上执行playbook的任务，发现卡住，但之前gather_facts已经跑通了。由此可知ansible可以在aix上跑任务，怀疑是raw模块的原因。于是将raw模块换成shell模块，成功执行。]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>aix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式Java实现]]></title>
    <url>%2F2019%2F01%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FJava%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[设计模式设计模式的分类设计模式总体来说分为三大类： 1 创建者模式，共五种：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式 2 结构型模式，共七种：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式 3 行为型模式：共十一种：策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式。 设计模式的六大原则总原则：开闭原则开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 单一职责原则每个类应该实现单一的职责，如若不然，应该把类拆分 里氏替换原则里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 依赖倒转原则面向接口编程，依赖于抽象而不依赖于具体。写代码用到具体类时，不与具体类交互，而与具体类的上层接口交互。 接口隔离原则每个接口不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口比使用单个接口要好。 迪米特原则（最少知道原则）一个类对自己依赖的类知道的越少越好。无论被依赖的类有多复杂，都应该将逻辑分装在方法的内部，通过public方法提供给外部。这样被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 合成复用原则原则上尽量首先使用合成/聚合的方式，而不是使用继承。 23种设计模式（基于Java)创建模式简单工厂模式简单工厂模式不属于23种设计模式之一。简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。 普通简单工厂就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 1234567891011121314151617181920212223242526272829303132333435363738// 创建共同接口public interface Sender &#123; void send();&#125;// 创建实现类public class MailSender implements Sender &#123; @Override public void send() &#123; System.out.println("This is a mail sender"); &#125;&#125;public class SmsSender implements Sender &#123; @Override public void send() &#123; System.out.println("This is a sms sender"); &#125;&#125;// 工厂类public class SendFactory &#123; public Sender produce(String type) &#123; if ("mail".equals(type)) &#123; return new MailSender(); &#125; else if ("sms".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println("Please input the right type!"); return null; &#125; &#125;&#125;// 测试类public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory sendFactory = new SendFactory(); Sender sender = sendFactory.produce("sms"); sender.send();// 输出：This is a sms sender &#125;&#125; 多方法简单工厂是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。 12345678910111213141516public class SendFactoryMulti &#123; public Sender produceMail() &#123; return new MailSender(); &#125; public Sender produceSms() &#123; return new SmsSender(); &#125;&#125;public class FactoryTestMulti &#123; public static void main(String[] args) &#123; SendFactoryMulti sendFactoryMulti = new SendFactoryMulti(); Sender sender = sendFactoryMulti.produceSms(); sender.send(); &#125;&#125; 多个静态方法将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 12345678910111213141516public class SendFactoryStatic &#123; public static Sender produceSms() &#123; return new SmsSender(); &#125; public static Sender producerMail() &#123; return new MailSender(); &#125;&#125;public class FactoryTestStatic &#123; public static void main(String[] args) &#123; Sender sender = SendFactoryStatic.producerMail(); sender.send(); &#125;&#125; 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 工厂方法模式（Factory Method）简单工厂模式有一个问题，类的创建依赖于工厂类，也就是说想要拓展程序必须修改工厂类，违背了闭包原则。如何解决？工厂方法模式，创建一个工厂接口和创建多个工厂的实现类，这样一旦添加新的功能，直接添加新的工厂类就可以了，不需要修改之前的代码。 1234567891011121314151617181920212223242526272829303132333435363738public interface Sender &#123; void send();&#125;public class MailSender implements Sender&#123; @Override public void send() &#123; System.out.println("Mail Sender"); &#125;&#125;public class SmsSender implements Sender &#123; @Override public void send() &#123; System.out.println("Sms Sender"); &#125;&#125;public interface Provider &#123; public Sender producer();&#125;public class SendMailFactory implements Provider &#123; @Override public Sender producer() &#123; return new SmsSender(); &#125;&#125;public class SendSmsFactory implements Provider &#123; @Override public Sender producer() &#123; return new SmsSender(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Provider provider = new SendMailFactory(); Sender sender = provider.producer(); sender.send(); &#125;&#125; 抽象工厂模式单例模式单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处： 1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 1234567891011121314151617181920212223242526272829303132333435363738public class Singleton &#123; // 私有构造方法，防止被实例化 private Singleton() &#123;&#125; // 使用一个内部类来维护单利 private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; // 获取实例 public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; // 如果该对象被用于序列化，可保证对象在序列化前后保持一致 public Object readResolve() &#123; return getInstance(); &#125;&#125;public class SingletonTest &#123; private static SingletonTest instance = null; private SingletonTest() &#123;&#125; private static synchronized void syncInit() &#123; if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125;&#125; 1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。 2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。 建造者模式原型模式原型模式虽然为创建型模式，但与工程模式没有关系，该模式的思想是将一个对象作为原型，对其进行复制，克隆，产生一个和原对象类似的新对象。在java中，复制对象是通过clone()实现的，先创建一个原型类： 参考：[1]: https://www.cnblogs.com/geek6/p/3951677.html “23种设计模式全解析”]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible基础之inventory]]></title>
    <url>%2F2019%2F01%2F18%2Fansible%E5%9F%BA%E7%A1%80%E4%B9%8Binventory%2F</url>
    <content type="text"><![CDATA[inventory的定义inventory是ansible里面用来管理主机的文件，在inventory文件里面，有组的概念，主机的概念，还可以定义inventory变量。inventory文件的示例如下： 123456789[mysql] 192.168.1.200192.168.1.201192.168.1.202[ams]192.168.1.220192.168.1.221[db: children]mysql 组和主机在inventory里面，组是一个逻辑上的概念，用来描述一组主机是来干什么的。组的定义通过一对中括号括起来，里面填写组的名字。如示例1所示，mysql和ams就是就是这个inventory文件里面定义的两个组。mysql组可能用来部署数据库服务器，ams组可能会用来部署ams应用。一个组下面的主机是属于这个组，一个主机可以属于多个组。 主机变量可以在inventory文件里定义主机变量。格式如下所示： 123456789[mysql] 192.168.1.200 ansible_ssh_user=mysql ansible_ssh_pass=mysql192.168.1.201192.168.1.202[ams]192.168.1.220192.168.1.221[db: children]mysql ansible_ssh_user和ansible_ssh_pass是主机192.168.1.200的主机变量，分别表示连接这台主机的用户名和密码。这两个变量属于ansible的内置变量，也可以定义自己的变量。 组变量组变量是属于某个组的变量，这个组里面的主机都能够使用这个变量。组变量的定义方式如下： 1234567[mysql] 192.168.1.200 ansible_ssh_user=mysql ansible_ssh_pass=mysql192.168.1.201192.168.1.202[mysql:vars]ntp_server=ntp.atlanta.example.comproxy=proxy.atlanta.example.com ntp_server和proxy为mysql这个组的组变量。主机变量的优先级高于组变量，也就是说，如果主机变量和组变量同名，那么主机变量将会覆盖组变量。 子组一个组可以是另一个组的孩子。 123456789[mysql] 192.168.1.200 ansible_ssh_user=mysql ansible_ssh_pass=mysql192.168.1.201192.168.1.202[ams]192.168.1.220192.168.1.221[db: children]mysql mysql这个组就是db组的孩子。对parent组进行操作，也会对其子组进行同样的操作。]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>inventory</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
</search>
