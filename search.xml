<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式Java实现]]></title>
    <url>%2F2019%2F01%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FJava%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[设计模式设计模式的分类设计模式总体来说分为三大类： 1 创建者模式，共五种：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式 2 结构型模式，共七种：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式 3 行为型模式：共十一种：策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式。 设计模式的六大原则总原则：开闭原则开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 单一职责原则每个类应该实现单一的职责，如若不然，应该把类拆分 里氏替换原则里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 依赖倒转原则面向接口编程，依赖于抽象而不依赖于具体。写代码用到具体类时，不与具体类交互，而与具体类的上层接口交互。 接口隔离原则每个接口不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口比使用单个接口要好。 迪米特原则（最少知道原则）一个类对自己依赖的类知道的越少越好。无论被依赖的类有多复杂，都应该将逻辑分装在方法的内部，通过public方法提供给外部。这样被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 合成复用原则原则上尽量首先使用合成/聚合的方式，而不是使用继承。 23种设计模式（基于Java)创建模式简单工厂模式简单工厂模式不属于23种设计模式之一。简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。 普通简单工厂就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 1234567891011121314151617181920212223242526272829303132333435363738// 创建共同接口public interface Sender &#123; void send();&#125;// 创建实现类public class MailSender implements Sender &#123; @Override public void send() &#123; System.out.println("This is a mail sender"); &#125;&#125;public class SmsSender implements Sender &#123; @Override public void send() &#123; System.out.println("This is a sms sender"); &#125;&#125;// 工厂类public class SendFactory &#123; public Sender produce(String type) &#123; if ("mail".equals(type)) &#123; return new MailSender(); &#125; else if ("sms".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println("Please input the right type!"); return null; &#125; &#125;&#125;// 测试类public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory sendFactory = new SendFactory(); Sender sender = sendFactory.produce("sms"); sender.send();// 输出：This is a sms sender &#125;&#125; 多方法简单工厂是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。 12345678910111213141516public class SendFactoryMulti &#123; public Sender produceMail() &#123; return new MailSender(); &#125; public Sender produceSms() &#123; return new SmsSender(); &#125;&#125;public class FactoryTestMulti &#123; public static void main(String[] args) &#123; SendFactoryMulti sendFactoryMulti = new SendFactoryMulti(); Sender sender = sendFactoryMulti.produceSms(); sender.send(); &#125;&#125; 多个静态方法将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 12345678910111213141516public class SendFactoryStatic &#123; public static Sender produceSms() &#123; return new SmsSender(); &#125; public static Sender producerMail() &#123; return new MailSender(); &#125;&#125;public class FactoryTestStatic &#123; public static void main(String[] args) &#123; Sender sender = SendFactoryStatic.producerMail(); sender.send(); &#125;&#125; 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 工厂方法模式（Factory Method）简单工厂模式有一个问题，类的创建依赖于工厂类，也就是说想要拓展程序必须修改工厂类，违背了闭包原则。如何解决？工厂方法模式，创建一个工厂接口和创建多个工厂的实现类，这样一旦添加新的功能，直接添加新的工厂类就可以了，不需要修改之前的代码。 1234567891011121314151617181920212223242526272829303132333435363738public interface Sender &#123; void send();&#125;public class MailSender implements Sender&#123; @Override public void send() &#123; System.out.println("Mail Sender"); &#125;&#125;public class SmsSender implements Sender &#123; @Override public void send() &#123; System.out.println("Sms Sender"); &#125;&#125;public interface Provider &#123; public Sender producer();&#125;public class SendMailFactory implements Provider &#123; @Override public Sender producer() &#123; return new SmsSender(); &#125;&#125;public class SendSmsFactory implements Provider &#123; @Override public Sender producer() &#123; return new SmsSender(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Provider provider = new SendMailFactory(); Sender sender = provider.producer(); sender.send(); &#125;&#125; 抽象工厂模式单例模式单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处： 1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 1234567891011121314151617181920212223242526272829303132333435363738public class Singleton &#123; // 私有构造方法，防止被实例化 private Singleton() &#123;&#125; // 使用一个内部类来维护单利 private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; // 获取实例 public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; // 如果该对象被用于序列化，可保证对象在序列化前后保持一致 public Object readResolve() &#123; return getInstance(); &#125;&#125;public class SingletonTest &#123; private static SingletonTest instance = null; private SingletonTest() &#123;&#125; private static synchronized void syncInit() &#123; if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125;&#125; 1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。 2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。 建造者模式原型模式原型模式虽然为创建型模式，但与工程模式没有关系，该模式的思想是将一个对象作为原型，对其进行复制，克隆，产生一个和原对象类似的新对象。在java中，复制对象是通过clone()实现的，先创建一个原型类： 参考：[1]: https://www.cnblogs.com/geek6/p/3951677.html “23种设计模式全解析”]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible基础之inventory]]></title>
    <url>%2F2019%2F01%2F18%2Fansible%E5%9F%BA%E7%A1%80%E4%B9%8Binventory%2F</url>
    <content type="text"><![CDATA[inventory的定义inventory是ansible里面用来管理主机的文件，在inventory文件里面，有组的概念，主机的概念，还可以定义inventory变量。inventory文件的示例如下： 123456789[mysql] 192.168.1.200192.168.1.201192.168.1.202[ams]192.168.1.220192.168.1.221[db: children]mysql 组和主机在inventory里面，组是一个逻辑上的概念，用来描述一组主机是来干什么的。组的定义通过一对中括号括起来，里面填写组的名字。如示例1所示，mysql和ams就是就是这个inventory文件里面定义的两个组。mysql组可能用来部署数据库服务器，ams组可能会用来部署ams应用。一个组下面的主机是属于这个组，一个主机可以属于多个组。 主机变量可以在inventory文件里定义主机变量。格式如下所示： 123456789[mysql] 192.168.1.200 ansible_ssh_user=mysql ansible_ssh_pass=mysql192.168.1.201192.168.1.202[ams]192.168.1.220192.168.1.221[db: children]mysql ansible_ssh_user和ansible_ssh_pass是主机192.168.1.200的主机变量，分别表示连接这台主机的用户名和密码。这两个变量属于ansible的内置变量，也可以定义自己的变量。 组变量组变量是属于某个组的变量，这个组里面的主机都能够使用这个变量。组变量的定义方式如下： 1234567[mysql] 192.168.1.200 ansible_ssh_user=mysql ansible_ssh_pass=mysql192.168.1.201192.168.1.202[mysql:vars]ntp_server=ntp.atlanta.example.comproxy=proxy.atlanta.example.com ntp_server和proxy为mysql这个组的组变量。主机变量的优先级高于组变量，也就是说，如果主机变量和组变量同名，那么主机变量将会覆盖组变量。 子组一个组可以是另一个组的孩子。 123456789[mysql] 192.168.1.200 ansible_ssh_user=mysql ansible_ssh_pass=mysql192.168.1.201192.168.1.202[ams]192.168.1.220192.168.1.221[db: children]mysql mysql这个组就是db组的孩子。对parent组进行操作，也会对其子组进行同样的操作。]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>inventory</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2019%2F01%2F17%2Fhello%2F</url>
    <content type="text"></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
