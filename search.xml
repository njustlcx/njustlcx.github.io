<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux基础知识]]></title>
    <url>%2F2019%2F01%2F19%2Flinux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[linux 基础命令切换目录12345cd user # 切换到当前目录下的user目录cd .. # 打开上一级目录cd / # 切换到系统根目录cd ~ # 切换到当前用户的主目录cd - # 切换到上一个命令所在的目录 目录的操作命令(增删改查)创建目录12mkdir mydir # 在当前目录下创建mydir目录mkdir -p lcx/test # 在当前的lcx目录下创建test目录，如果lcx目录不存在，则创建 查看目录信息123ls # 查看当前目录下的文件(不包括以"."开头的文件)ls -a # 查看当前目录下的所有文件（包括以 "." 开头的文件)ll # ls -l的缩写。查看当前目录下所有文件和目录的详细信息(我一般使用这个命令查看权限较多) find命令用法：find 目录 参数 123find . # 列出当前目录以及子目录下的所有文件和文件夹find / -name "*.txt" # 找出系统根目录下以.txt结尾的文件find / -iname "*.txt" # 同上，但忽略大小写 mv命令mv命令可以对目录、文件进行重命名，也可以将一个文件从一个目录移动到另一个目录 12mv lcx user # 将lcx目录重新命名为user目录mv lcx.txt ../user # 将lcx.txt从当前目录移动到上级目录的user目录 cp 命令cp命令对文件和目录进行复制。用法：cp 目录名称 目标目录名称 12cp -r lcx lcx2 # 将lcx目录复制到lcx2目录，-r表示递归复制cp lcx.txt lcx2.txt # 将lcx.txt 复制一份到lcx2.txt 删除目录1rm -rf lcx # 删除lcx目录 文件操作相关命令创建文件1touch 1.txt # 创建1.txt 查看文件内容1cat 1.txt # 查看1.txt的内容 编辑文件内容1vim 1.txt # 编辑1.txt。按i进入vim的编辑模式，编辑好之后按ESC进入命令模式，最后按":wq"保存编辑好的文件并退出 删除文件1rm -rf 1.txt # 删除1.txt]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nexus安装步骤]]></title>
    <url>%2F2019%2F01%2F18%2Fnexus%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[拉取安装包(nexus-3.15.1-01-unix.tar.gz)到指定目录打开8081端口123tar -zxvf nexus-3.15.1-01-unix.tar.gzcd nexus-3.15.1-01/bin./nexus run &amp; 启动成功即可。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>nexus</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java值传递]]></title>
    <url>%2F2019%2F01%2F18%2FJava%E5%80%BC%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[linux免密登录]]></title>
    <url>%2F2019%2F01%2F18%2Flinux%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[环境两台主机：192.168.1.230 192.168.1.231。现在需要通过ssh，实现192.168.1.230到231的免密登录。 生成密钥在192.168.1.230上生成一对密钥，一个作为公钥，一个作为s私钥。如果已有对应的公钥和私钥，则不需要这一步。命令如下： 1ssh-keygen 一直按回车就行。 出现红框内的图案表示密钥生成成功。可以发现用户的.ssh目录下出现了id_rsa和id_rsa.pub，前者为私钥，后者为公钥。 部署公钥到目标主机在当前服务器执行ssh-copy-id命令，将公钥部署到目标服务器，用法如下： 12# 命令格式：ssh-copy-id 用户名@ip地址ssh-copy-id shqz@192.168.1.231 执行这条命令之后需要输入目标主机的登录密码，输入之后即可进行免密登录。 出现上图表示公钥部署成功。 免密登录前面已经将密钥配置完成，最后只需要执行如下ssh命令即可免密登录： 1ssh shqz@192.168.1.231 发现，无需输入密码就登录到目标主机。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible问题记录]]></title>
    <url>%2F2019%2F01%2F18%2Fansible%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[关于aixansible连接不了aix服务器首先判断是不是aix服务器上没有python环境，如果没有，需要先安装合适版本的python环境。发现安装python环境之后依旧连接不上，不知道问题在哪。后来尝试加入连接方式，使用命令行参数-c，指定连接方式为paramiko，就连接成功了。 ansible无法执行aix的任务使用raw模块在aix上执行playbook的任务，发现卡住，但之前gather_facts已经跑通了。由此可知ansible可以在aix上跑任务，怀疑是raw模块的原因。于是将raw模块换成shell模块，成功执行。]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>aix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式Java实现]]></title>
    <url>%2F2019%2F01%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FJava%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[设计模式设计模式的分类设计模式总体来说分为三大类： 1 创建者模式，共五种：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式 2 结构型模式，共七种：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式 3 行为型模式：共十一种：策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式。 设计模式的六大原则总原则：开闭原则开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 单一职责原则每个类应该实现单一的职责，如若不然，应该把类拆分 里氏替换原则里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 依赖倒转原则面向接口编程，依赖于抽象而不依赖于具体。写代码用到具体类时，不与具体类交互，而与具体类的上层接口交互。 接口隔离原则每个接口不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口比使用单个接口要好。 迪米特原则（最少知道原则）一个类对自己依赖的类知道的越少越好。无论被依赖的类有多复杂，都应该将逻辑分装在方法的内部，通过public方法提供给外部。这样被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 合成复用原则原则上尽量首先使用合成/聚合的方式，而不是使用继承。 23种设计模式（基于Java)创建模式简单工厂模式简单工厂模式不属于23种设计模式之一。简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。 普通简单工厂就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 1234567891011121314151617181920212223242526272829303132333435363738// 创建共同接口public interface Sender &#123; void send();&#125;// 创建实现类public class MailSender implements Sender &#123; @Override public void send() &#123; System.out.println("This is a mail sender"); &#125;&#125;public class SmsSender implements Sender &#123; @Override public void send() &#123; System.out.println("This is a sms sender"); &#125;&#125;// 工厂类public class SendFactory &#123; public Sender produce(String type) &#123; if ("mail".equals(type)) &#123; return new MailSender(); &#125; else if ("sms".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println("Please input the right type!"); return null; &#125; &#125;&#125;// 测试类public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory sendFactory = new SendFactory(); Sender sender = sendFactory.produce("sms"); sender.send();// 输出：This is a sms sender &#125;&#125; 多方法简单工厂是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。 12345678910111213141516public class SendFactoryMulti &#123; public Sender produceMail() &#123; return new MailSender(); &#125; public Sender produceSms() &#123; return new SmsSender(); &#125;&#125;public class FactoryTestMulti &#123; public static void main(String[] args) &#123; SendFactoryMulti sendFactoryMulti = new SendFactoryMulti(); Sender sender = sendFactoryMulti.produceSms(); sender.send(); &#125;&#125; 多个静态方法将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 12345678910111213141516public class SendFactoryStatic &#123; public static Sender produceSms() &#123; return new SmsSender(); &#125; public static Sender producerMail() &#123; return new MailSender(); &#125;&#125;public class FactoryTestStatic &#123; public static void main(String[] args) &#123; Sender sender = SendFactoryStatic.producerMail(); sender.send(); &#125;&#125; 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 工厂方法模式（Factory Method）简单工厂模式有一个问题，类的创建依赖于工厂类，也就是说想要拓展程序必须修改工厂类，违背了闭包原则。如何解决？工厂方法模式，创建一个工厂接口和创建多个工厂的实现类，这样一旦添加新的功能，直接添加新的工厂类就可以了，不需要修改之前的代码。 1234567891011121314151617181920212223242526272829303132333435363738public interface Sender &#123; void send();&#125;public class MailSender implements Sender&#123; @Override public void send() &#123; System.out.println("Mail Sender"); &#125;&#125;public class SmsSender implements Sender &#123; @Override public void send() &#123; System.out.println("Sms Sender"); &#125;&#125;public interface Provider &#123; public Sender producer();&#125;public class SendMailFactory implements Provider &#123; @Override public Sender producer() &#123; return new SmsSender(); &#125;&#125;public class SendSmsFactory implements Provider &#123; @Override public Sender producer() &#123; return new SmsSender(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Provider provider = new SendMailFactory(); Sender sender = provider.producer(); sender.send(); &#125;&#125; 抽象工厂模式单例模式单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处： 1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 1234567891011121314151617181920212223242526272829303132333435363738public class Singleton &#123; // 私有构造方法，防止被实例化 private Singleton() &#123;&#125; // 使用一个内部类来维护单利 private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; // 获取实例 public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; // 如果该对象被用于序列化，可保证对象在序列化前后保持一致 public Object readResolve() &#123; return getInstance(); &#125;&#125;public class SingletonTest &#123; private static SingletonTest instance = null; private SingletonTest() &#123;&#125; private static synchronized void syncInit() &#123; if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125;&#125; 1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。 2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。 建造者模式原型模式原型模式虽然为创建型模式，但与工程模式没有关系，该模式的思想是将一个对象作为原型，对其进行复制，克隆，产生一个和原对象类似的新对象。在java中，复制对象是通过clone()实现的，先创建一个原型类： 参考：[1]: https://www.cnblogs.com/geek6/p/3951677.html “23种设计模式全解析”]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible基础之inventory]]></title>
    <url>%2F2019%2F01%2F18%2Fansible%E5%9F%BA%E7%A1%80%E4%B9%8Binventory%2F</url>
    <content type="text"><![CDATA[inventory的定义inventory是ansible里面用来管理主机的文件，在inventory文件里面，有组的概念，主机的概念，还可以定义inventory变量。inventory文件的示例如下： 123456789[mysql] 192.168.1.200192.168.1.201192.168.1.202[ams]192.168.1.220192.168.1.221[db: children]mysql 组和主机在inventory里面，组是一个逻辑上的概念，用来描述一组主机是来干什么的。组的定义通过一对中括号括起来，里面填写组的名字。如示例1所示，mysql和ams就是就是这个inventory文件里面定义的两个组。mysql组可能用来部署数据库服务器，ams组可能会用来部署ams应用。一个组下面的主机是属于这个组，一个主机可以属于多个组。 主机变量可以在inventory文件里定义主机变量。格式如下所示： 123456789[mysql] 192.168.1.200 ansible_ssh_user=mysql ansible_ssh_pass=mysql192.168.1.201192.168.1.202[ams]192.168.1.220192.168.1.221[db: children]mysql ansible_ssh_user和ansible_ssh_pass是主机192.168.1.200的主机变量，分别表示连接这台主机的用户名和密码。这两个变量属于ansible的内置变量，也可以定义自己的变量。 组变量组变量是属于某个组的变量，这个组里面的主机都能够使用这个变量。组变量的定义方式如下： 1234567[mysql] 192.168.1.200 ansible_ssh_user=mysql ansible_ssh_pass=mysql192.168.1.201192.168.1.202[mysql:vars]ntp_server=ntp.atlanta.example.comproxy=proxy.atlanta.example.com ntp_server和proxy为mysql这个组的组变量。主机变量的优先级高于组变量，也就是说，如果主机变量和组变量同名，那么主机变量将会覆盖组变量。 子组一个组可以是另一个组的孩子。 123456789[mysql] 192.168.1.200 ansible_ssh_user=mysql ansible_ssh_pass=mysql192.168.1.201192.168.1.202[ams]192.168.1.220192.168.1.221[db: children]mysql mysql这个组就是db组的孩子。对parent组进行操作，也会对其子组进行同样的操作。]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>inventory</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2019%2F01%2F17%2Fhello%2F</url>
    <content type="text"></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
